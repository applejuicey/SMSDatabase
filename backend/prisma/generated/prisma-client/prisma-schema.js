module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.27.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCompound {
  count: Int!
}

type AggregateNegativeMSData {
  count: Int!
}

type AggregatePositiveMSData {
  count: Int!
}

type AggregateSaponinsSource {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Compound {
  id: ID!
  commonName: String!
  casCode: String
  pubChemCID: String
  chemSpiderID: String
  smiles: String!
  chemicalFormula: String
  positiveMSData: PositiveMSData
  negativeMSData: NegativeMSData
  saponinsSource: SaponinsSource
}

type CompoundConnection {
  pageInfo: PageInfo!
  edges: [CompoundEdge]!
  aggregate: AggregateCompound!
}

input CompoundCreateInput {
  commonName: String!
  casCode: String
  pubChemCID: String
  chemSpiderID: String
  smiles: String!
  chemicalFormula: String
  positiveMSData: PositiveMSDataCreateOneInput
  negativeMSData: NegativeMSDataCreateOneInput
  saponinsSource: SaponinsSourceCreateOneInput
}

type CompoundEdge {
  node: Compound!
  cursor: String!
}

enum CompoundOrderByInput {
  id_ASC
  id_DESC
  commonName_ASC
  commonName_DESC
  casCode_ASC
  casCode_DESC
  pubChemCID_ASC
  pubChemCID_DESC
  chemSpiderID_ASC
  chemSpiderID_DESC
  smiles_ASC
  smiles_DESC
  chemicalFormula_ASC
  chemicalFormula_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CompoundPreviousValues {
  id: ID!
  commonName: String!
  casCode: String
  pubChemCID: String
  chemSpiderID: String
  smiles: String!
  chemicalFormula: String
}

type CompoundSubscriptionPayload {
  mutation: MutationType!
  node: Compound
  updatedFields: [String!]
  previousValues: CompoundPreviousValues
}

input CompoundSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompoundWhereInput
  AND: [CompoundSubscriptionWhereInput!]
  OR: [CompoundSubscriptionWhereInput!]
  NOT: [CompoundSubscriptionWhereInput!]
}

input CompoundUpdateInput {
  commonName: String
  casCode: String
  pubChemCID: String
  chemSpiderID: String
  smiles: String
  chemicalFormula: String
  positiveMSData: PositiveMSDataUpdateOneInput
  negativeMSData: NegativeMSDataUpdateOneInput
  saponinsSource: SaponinsSourceUpdateOneInput
}

input CompoundUpdateManyMutationInput {
  commonName: String
  casCode: String
  pubChemCID: String
  chemSpiderID: String
  smiles: String
  chemicalFormula: String
}

input CompoundWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  commonName: String
  commonName_not: String
  commonName_in: [String!]
  commonName_not_in: [String!]
  commonName_lt: String
  commonName_lte: String
  commonName_gt: String
  commonName_gte: String
  commonName_contains: String
  commonName_not_contains: String
  commonName_starts_with: String
  commonName_not_starts_with: String
  commonName_ends_with: String
  commonName_not_ends_with: String
  casCode: String
  casCode_not: String
  casCode_in: [String!]
  casCode_not_in: [String!]
  casCode_lt: String
  casCode_lte: String
  casCode_gt: String
  casCode_gte: String
  casCode_contains: String
  casCode_not_contains: String
  casCode_starts_with: String
  casCode_not_starts_with: String
  casCode_ends_with: String
  casCode_not_ends_with: String
  pubChemCID: String
  pubChemCID_not: String
  pubChemCID_in: [String!]
  pubChemCID_not_in: [String!]
  pubChemCID_lt: String
  pubChemCID_lte: String
  pubChemCID_gt: String
  pubChemCID_gte: String
  pubChemCID_contains: String
  pubChemCID_not_contains: String
  pubChemCID_starts_with: String
  pubChemCID_not_starts_with: String
  pubChemCID_ends_with: String
  pubChemCID_not_ends_with: String
  chemSpiderID: String
  chemSpiderID_not: String
  chemSpiderID_in: [String!]
  chemSpiderID_not_in: [String!]
  chemSpiderID_lt: String
  chemSpiderID_lte: String
  chemSpiderID_gt: String
  chemSpiderID_gte: String
  chemSpiderID_contains: String
  chemSpiderID_not_contains: String
  chemSpiderID_starts_with: String
  chemSpiderID_not_starts_with: String
  chemSpiderID_ends_with: String
  chemSpiderID_not_ends_with: String
  smiles: String
  smiles_not: String
  smiles_in: [String!]
  smiles_not_in: [String!]
  smiles_lt: String
  smiles_lte: String
  smiles_gt: String
  smiles_gte: String
  smiles_contains: String
  smiles_not_contains: String
  smiles_starts_with: String
  smiles_not_starts_with: String
  smiles_ends_with: String
  smiles_not_ends_with: String
  chemicalFormula: String
  chemicalFormula_not: String
  chemicalFormula_in: [String!]
  chemicalFormula_not_in: [String!]
  chemicalFormula_lt: String
  chemicalFormula_lte: String
  chemicalFormula_gt: String
  chemicalFormula_gte: String
  chemicalFormula_contains: String
  chemicalFormula_not_contains: String
  chemicalFormula_starts_with: String
  chemicalFormula_not_starts_with: String
  chemicalFormula_ends_with: String
  chemicalFormula_not_ends_with: String
  positiveMSData: PositiveMSDataWhereInput
  negativeMSData: NegativeMSDataWhereInput
  saponinsSource: SaponinsSourceWhereInput
  AND: [CompoundWhereInput!]
  OR: [CompoundWhereInput!]
  NOT: [CompoundWhereInput!]
}

input CompoundWhereUniqueInput {
  id: ID
  smiles: String
}

scalar Long

type Mutation {
  createCompound(data: CompoundCreateInput!): Compound!
  updateCompound(data: CompoundUpdateInput!, where: CompoundWhereUniqueInput!): Compound
  updateManyCompounds(data: CompoundUpdateManyMutationInput!, where: CompoundWhereInput): BatchPayload!
  upsertCompound(where: CompoundWhereUniqueInput!, create: CompoundCreateInput!, update: CompoundUpdateInput!): Compound!
  deleteCompound(where: CompoundWhereUniqueInput!): Compound
  deleteManyCompounds(where: CompoundWhereInput): BatchPayload!
  createNegativeMSData(data: NegativeMSDataCreateInput!): NegativeMSData!
  updateNegativeMSData(data: NegativeMSDataUpdateInput!, where: NegativeMSDataWhereUniqueInput!): NegativeMSData
  updateManyNegativeMSDatas(data: NegativeMSDataUpdateManyMutationInput!, where: NegativeMSDataWhereInput): BatchPayload!
  upsertNegativeMSData(where: NegativeMSDataWhereUniqueInput!, create: NegativeMSDataCreateInput!, update: NegativeMSDataUpdateInput!): NegativeMSData!
  deleteNegativeMSData(where: NegativeMSDataWhereUniqueInput!): NegativeMSData
  deleteManyNegativeMSDatas(where: NegativeMSDataWhereInput): BatchPayload!
  createPositiveMSData(data: PositiveMSDataCreateInput!): PositiveMSData!
  updatePositiveMSData(data: PositiveMSDataUpdateInput!, where: PositiveMSDataWhereUniqueInput!): PositiveMSData
  updateManyPositiveMSDatas(data: PositiveMSDataUpdateManyMutationInput!, where: PositiveMSDataWhereInput): BatchPayload!
  upsertPositiveMSData(where: PositiveMSDataWhereUniqueInput!, create: PositiveMSDataCreateInput!, update: PositiveMSDataUpdateInput!): PositiveMSData!
  deletePositiveMSData(where: PositiveMSDataWhereUniqueInput!): PositiveMSData
  deleteManyPositiveMSDatas(where: PositiveMSDataWhereInput): BatchPayload!
  createSaponinsSource(data: SaponinsSourceCreateInput!): SaponinsSource!
  updateSaponinsSource(data: SaponinsSourceUpdateInput!, where: SaponinsSourceWhereUniqueInput!): SaponinsSource
  updateManySaponinsSources(data: SaponinsSourceUpdateManyMutationInput!, where: SaponinsSourceWhereInput): BatchPayload!
  upsertSaponinsSource(where: SaponinsSourceWhereUniqueInput!, create: SaponinsSourceCreateInput!, update: SaponinsSourceUpdateInput!): SaponinsSource!
  deleteSaponinsSource(where: SaponinsSourceWhereUniqueInput!): SaponinsSource
  deleteManySaponinsSources(where: SaponinsSourceWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type NegativeMSData {
  id: ID!
  parentValue: Float!
  fragmentsValues: [Float!]!
  dataSource: String
  referenceCodes: [String!]!
}

type NegativeMSDataConnection {
  pageInfo: PageInfo!
  edges: [NegativeMSDataEdge]!
  aggregate: AggregateNegativeMSData!
}

input NegativeMSDataCreatefragmentsValuesInput {
  set: [Float!]
}

input NegativeMSDataCreateInput {
  parentValue: Float!
  fragmentsValues: NegativeMSDataCreatefragmentsValuesInput
  dataSource: String
  referenceCodes: NegativeMSDataCreatereferenceCodesInput
}

input NegativeMSDataCreateOneInput {
  create: NegativeMSDataCreateInput
  connect: NegativeMSDataWhereUniqueInput
}

input NegativeMSDataCreatereferenceCodesInput {
  set: [String!]
}

type NegativeMSDataEdge {
  node: NegativeMSData!
  cursor: String!
}

enum NegativeMSDataOrderByInput {
  id_ASC
  id_DESC
  parentValue_ASC
  parentValue_DESC
  dataSource_ASC
  dataSource_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NegativeMSDataPreviousValues {
  id: ID!
  parentValue: Float!
  fragmentsValues: [Float!]!
  dataSource: String
  referenceCodes: [String!]!
}

type NegativeMSDataSubscriptionPayload {
  mutation: MutationType!
  node: NegativeMSData
  updatedFields: [String!]
  previousValues: NegativeMSDataPreviousValues
}

input NegativeMSDataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NegativeMSDataWhereInput
  AND: [NegativeMSDataSubscriptionWhereInput!]
  OR: [NegativeMSDataSubscriptionWhereInput!]
  NOT: [NegativeMSDataSubscriptionWhereInput!]
}

input NegativeMSDataUpdateDataInput {
  parentValue: Float
  fragmentsValues: NegativeMSDataUpdatefragmentsValuesInput
  dataSource: String
  referenceCodes: NegativeMSDataUpdatereferenceCodesInput
}

input NegativeMSDataUpdatefragmentsValuesInput {
  set: [Float!]
}

input NegativeMSDataUpdateInput {
  parentValue: Float
  fragmentsValues: NegativeMSDataUpdatefragmentsValuesInput
  dataSource: String
  referenceCodes: NegativeMSDataUpdatereferenceCodesInput
}

input NegativeMSDataUpdateManyMutationInput {
  parentValue: Float
  fragmentsValues: NegativeMSDataUpdatefragmentsValuesInput
  dataSource: String
  referenceCodes: NegativeMSDataUpdatereferenceCodesInput
}

input NegativeMSDataUpdateOneInput {
  create: NegativeMSDataCreateInput
  update: NegativeMSDataUpdateDataInput
  upsert: NegativeMSDataUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: NegativeMSDataWhereUniqueInput
}

input NegativeMSDataUpdatereferenceCodesInput {
  set: [String!]
}

input NegativeMSDataUpsertNestedInput {
  update: NegativeMSDataUpdateDataInput!
  create: NegativeMSDataCreateInput!
}

input NegativeMSDataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  parentValue: Float
  parentValue_not: Float
  parentValue_in: [Float!]
  parentValue_not_in: [Float!]
  parentValue_lt: Float
  parentValue_lte: Float
  parentValue_gt: Float
  parentValue_gte: Float
  dataSource: String
  dataSource_not: String
  dataSource_in: [String!]
  dataSource_not_in: [String!]
  dataSource_lt: String
  dataSource_lte: String
  dataSource_gt: String
  dataSource_gte: String
  dataSource_contains: String
  dataSource_not_contains: String
  dataSource_starts_with: String
  dataSource_not_starts_with: String
  dataSource_ends_with: String
  dataSource_not_ends_with: String
  AND: [NegativeMSDataWhereInput!]
  OR: [NegativeMSDataWhereInput!]
  NOT: [NegativeMSDataWhereInput!]
}

input NegativeMSDataWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PositiveMSData {
  id: ID!
  parentValue: Float!
  fragmentsValues: [Float!]!
  dataSource: String
  referenceCodes: [String!]!
}

type PositiveMSDataConnection {
  pageInfo: PageInfo!
  edges: [PositiveMSDataEdge]!
  aggregate: AggregatePositiveMSData!
}

input PositiveMSDataCreatefragmentsValuesInput {
  set: [Float!]
}

input PositiveMSDataCreateInput {
  parentValue: Float!
  fragmentsValues: PositiveMSDataCreatefragmentsValuesInput
  dataSource: String
  referenceCodes: PositiveMSDataCreatereferenceCodesInput
}

input PositiveMSDataCreateOneInput {
  create: PositiveMSDataCreateInput
  connect: PositiveMSDataWhereUniqueInput
}

input PositiveMSDataCreatereferenceCodesInput {
  set: [String!]
}

type PositiveMSDataEdge {
  node: PositiveMSData!
  cursor: String!
}

enum PositiveMSDataOrderByInput {
  id_ASC
  id_DESC
  parentValue_ASC
  parentValue_DESC
  dataSource_ASC
  dataSource_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PositiveMSDataPreviousValues {
  id: ID!
  parentValue: Float!
  fragmentsValues: [Float!]!
  dataSource: String
  referenceCodes: [String!]!
}

type PositiveMSDataSubscriptionPayload {
  mutation: MutationType!
  node: PositiveMSData
  updatedFields: [String!]
  previousValues: PositiveMSDataPreviousValues
}

input PositiveMSDataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PositiveMSDataWhereInput
  AND: [PositiveMSDataSubscriptionWhereInput!]
  OR: [PositiveMSDataSubscriptionWhereInput!]
  NOT: [PositiveMSDataSubscriptionWhereInput!]
}

input PositiveMSDataUpdateDataInput {
  parentValue: Float
  fragmentsValues: PositiveMSDataUpdatefragmentsValuesInput
  dataSource: String
  referenceCodes: PositiveMSDataUpdatereferenceCodesInput
}

input PositiveMSDataUpdatefragmentsValuesInput {
  set: [Float!]
}

input PositiveMSDataUpdateInput {
  parentValue: Float
  fragmentsValues: PositiveMSDataUpdatefragmentsValuesInput
  dataSource: String
  referenceCodes: PositiveMSDataUpdatereferenceCodesInput
}

input PositiveMSDataUpdateManyMutationInput {
  parentValue: Float
  fragmentsValues: PositiveMSDataUpdatefragmentsValuesInput
  dataSource: String
  referenceCodes: PositiveMSDataUpdatereferenceCodesInput
}

input PositiveMSDataUpdateOneInput {
  create: PositiveMSDataCreateInput
  update: PositiveMSDataUpdateDataInput
  upsert: PositiveMSDataUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PositiveMSDataWhereUniqueInput
}

input PositiveMSDataUpdatereferenceCodesInput {
  set: [String!]
}

input PositiveMSDataUpsertNestedInput {
  update: PositiveMSDataUpdateDataInput!
  create: PositiveMSDataCreateInput!
}

input PositiveMSDataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  parentValue: Float
  parentValue_not: Float
  parentValue_in: [Float!]
  parentValue_not_in: [Float!]
  parentValue_lt: Float
  parentValue_lte: Float
  parentValue_gt: Float
  parentValue_gte: Float
  dataSource: String
  dataSource_not: String
  dataSource_in: [String!]
  dataSource_not_in: [String!]
  dataSource_lt: String
  dataSource_lte: String
  dataSource_gt: String
  dataSource_gte: String
  dataSource_contains: String
  dataSource_not_contains: String
  dataSource_starts_with: String
  dataSource_not_starts_with: String
  dataSource_ends_with: String
  dataSource_not_ends_with: String
  AND: [PositiveMSDataWhereInput!]
  OR: [PositiveMSDataWhereInput!]
  NOT: [PositiveMSDataWhereInput!]
}

input PositiveMSDataWhereUniqueInput {
  id: ID
}

type Query {
  compound(where: CompoundWhereUniqueInput!): Compound
  compounds(where: CompoundWhereInput, orderBy: CompoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Compound]!
  compoundsConnection(where: CompoundWhereInput, orderBy: CompoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompoundConnection!
  negativeMSData(where: NegativeMSDataWhereUniqueInput!): NegativeMSData
  negativeMSDatas(where: NegativeMSDataWhereInput, orderBy: NegativeMSDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NegativeMSData]!
  negativeMSDatasConnection(where: NegativeMSDataWhereInput, orderBy: NegativeMSDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NegativeMSDataConnection!
  positiveMSData(where: PositiveMSDataWhereUniqueInput!): PositiveMSData
  positiveMSDatas(where: PositiveMSDataWhereInput, orderBy: PositiveMSDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PositiveMSData]!
  positiveMSDatasConnection(where: PositiveMSDataWhereInput, orderBy: PositiveMSDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PositiveMSDataConnection!
  saponinsSource(where: SaponinsSourceWhereUniqueInput!): SaponinsSource
  saponinsSources(where: SaponinsSourceWhereInput, orderBy: SaponinsSourceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SaponinsSource]!
  saponinsSourcesConnection(where: SaponinsSourceWhereInput, orderBy: SaponinsSourceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SaponinsSourceConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum RoleType {
  ROOT
  ADMIN
  USER
}

type SaponinsSource {
  id: ID!
  sourceCodes: [String!]!
}

type SaponinsSourceConnection {
  pageInfo: PageInfo!
  edges: [SaponinsSourceEdge]!
  aggregate: AggregateSaponinsSource!
}

input SaponinsSourceCreateInput {
  sourceCodes: SaponinsSourceCreatesourceCodesInput
}

input SaponinsSourceCreateOneInput {
  create: SaponinsSourceCreateInput
  connect: SaponinsSourceWhereUniqueInput
}

input SaponinsSourceCreatesourceCodesInput {
  set: [String!]
}

type SaponinsSourceEdge {
  node: SaponinsSource!
  cursor: String!
}

enum SaponinsSourceOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SaponinsSourcePreviousValues {
  id: ID!
  sourceCodes: [String!]!
}

type SaponinsSourceSubscriptionPayload {
  mutation: MutationType!
  node: SaponinsSource
  updatedFields: [String!]
  previousValues: SaponinsSourcePreviousValues
}

input SaponinsSourceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SaponinsSourceWhereInput
  AND: [SaponinsSourceSubscriptionWhereInput!]
  OR: [SaponinsSourceSubscriptionWhereInput!]
  NOT: [SaponinsSourceSubscriptionWhereInput!]
}

input SaponinsSourceUpdateDataInput {
  sourceCodes: SaponinsSourceUpdatesourceCodesInput
}

input SaponinsSourceUpdateInput {
  sourceCodes: SaponinsSourceUpdatesourceCodesInput
}

input SaponinsSourceUpdateManyMutationInput {
  sourceCodes: SaponinsSourceUpdatesourceCodesInput
}

input SaponinsSourceUpdateOneInput {
  create: SaponinsSourceCreateInput
  update: SaponinsSourceUpdateDataInput
  upsert: SaponinsSourceUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SaponinsSourceWhereUniqueInput
}

input SaponinsSourceUpdatesourceCodesInput {
  set: [String!]
}

input SaponinsSourceUpsertNestedInput {
  update: SaponinsSourceUpdateDataInput!
  create: SaponinsSourceCreateInput!
}

input SaponinsSourceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SaponinsSourceWhereInput!]
  OR: [SaponinsSourceWhereInput!]
  NOT: [SaponinsSourceWhereInput!]
}

input SaponinsSourceWhereUniqueInput {
  id: ID
}

type Subscription {
  compound(where: CompoundSubscriptionWhereInput): CompoundSubscriptionPayload
  negativeMSData(where: NegativeMSDataSubscriptionWhereInput): NegativeMSDataSubscriptionPayload
  positiveMSData(where: PositiveMSDataSubscriptionWhereInput): PositiveMSDataSubscriptionPayload
  saponinsSource(where: SaponinsSourceSubscriptionWhereInput): SaponinsSourceSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String
  email: String!
  password: String!
  role: RoleType!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  name: String
  email: String!
  password: String!
  role: RoleType
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String
  email: String!
  password: String!
  role: RoleType!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  role: RoleType
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
  role: RoleType
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: RoleType
  role_not: RoleType
  role_in: [RoleType!]
  role_not_in: [RoleType!]
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    