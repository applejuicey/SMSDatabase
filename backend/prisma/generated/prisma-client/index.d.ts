// Code generated by Prisma (prisma@1.27.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  compound: (where?: CompoundWhereInput) => Promise<boolean>;
  negativeMSData: (where?: NegativeMSDataWhereInput) => Promise<boolean>;
  positiveMSData: (where?: PositiveMSDataWhereInput) => Promise<boolean>;
  saponinsSource: (where?: SaponinsSourceWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  compound: (where: CompoundWhereUniqueInput) => CompoundPromise;
  compounds: (
    args?: {
      where?: CompoundWhereInput;
      orderBy?: CompoundOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Compound>;
  compoundsConnection: (
    args?: {
      where?: CompoundWhereInput;
      orderBy?: CompoundOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompoundConnectionPromise;
  negativeMSData: (
    where: NegativeMSDataWhereUniqueInput
  ) => NegativeMSDataPromise;
  negativeMSDatas: (
    args?: {
      where?: NegativeMSDataWhereInput;
      orderBy?: NegativeMSDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<NegativeMSData>;
  negativeMSDatasConnection: (
    args?: {
      where?: NegativeMSDataWhereInput;
      orderBy?: NegativeMSDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NegativeMSDataConnectionPromise;
  positiveMSData: (
    where: PositiveMSDataWhereUniqueInput
  ) => PositiveMSDataPromise;
  positiveMSDatas: (
    args?: {
      where?: PositiveMSDataWhereInput;
      orderBy?: PositiveMSDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PositiveMSData>;
  positiveMSDatasConnection: (
    args?: {
      where?: PositiveMSDataWhereInput;
      orderBy?: PositiveMSDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PositiveMSDataConnectionPromise;
  saponinsSource: (
    where: SaponinsSourceWhereUniqueInput
  ) => SaponinsSourcePromise;
  saponinsSources: (
    args?: {
      where?: SaponinsSourceWhereInput;
      orderBy?: SaponinsSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SaponinsSource>;
  saponinsSourcesConnection: (
    args?: {
      where?: SaponinsSourceWhereInput;
      orderBy?: SaponinsSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SaponinsSourceConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCompound: (data: CompoundCreateInput) => CompoundPromise;
  updateCompound: (
    args: { data: CompoundUpdateInput; where: CompoundWhereUniqueInput }
  ) => CompoundPromise;
  updateManyCompounds: (
    args: { data: CompoundUpdateManyMutationInput; where?: CompoundWhereInput }
  ) => BatchPayloadPromise;
  upsertCompound: (
    args: {
      where: CompoundWhereUniqueInput;
      create: CompoundCreateInput;
      update: CompoundUpdateInput;
    }
  ) => CompoundPromise;
  deleteCompound: (where: CompoundWhereUniqueInput) => CompoundPromise;
  deleteManyCompounds: (where?: CompoundWhereInput) => BatchPayloadPromise;
  createNegativeMSData: (
    data: NegativeMSDataCreateInput
  ) => NegativeMSDataPromise;
  updateNegativeMSData: (
    args: {
      data: NegativeMSDataUpdateInput;
      where: NegativeMSDataWhereUniqueInput;
    }
  ) => NegativeMSDataPromise;
  updateManyNegativeMSDatas: (
    args: {
      data: NegativeMSDataUpdateManyMutationInput;
      where?: NegativeMSDataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertNegativeMSData: (
    args: {
      where: NegativeMSDataWhereUniqueInput;
      create: NegativeMSDataCreateInput;
      update: NegativeMSDataUpdateInput;
    }
  ) => NegativeMSDataPromise;
  deleteNegativeMSData: (
    where: NegativeMSDataWhereUniqueInput
  ) => NegativeMSDataPromise;
  deleteManyNegativeMSDatas: (
    where?: NegativeMSDataWhereInput
  ) => BatchPayloadPromise;
  createPositiveMSData: (
    data: PositiveMSDataCreateInput
  ) => PositiveMSDataPromise;
  updatePositiveMSData: (
    args: {
      data: PositiveMSDataUpdateInput;
      where: PositiveMSDataWhereUniqueInput;
    }
  ) => PositiveMSDataPromise;
  updateManyPositiveMSDatas: (
    args: {
      data: PositiveMSDataUpdateManyMutationInput;
      where?: PositiveMSDataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPositiveMSData: (
    args: {
      where: PositiveMSDataWhereUniqueInput;
      create: PositiveMSDataCreateInput;
      update: PositiveMSDataUpdateInput;
    }
  ) => PositiveMSDataPromise;
  deletePositiveMSData: (
    where: PositiveMSDataWhereUniqueInput
  ) => PositiveMSDataPromise;
  deleteManyPositiveMSDatas: (
    where?: PositiveMSDataWhereInput
  ) => BatchPayloadPromise;
  createSaponinsSource: (
    data: SaponinsSourceCreateInput
  ) => SaponinsSourcePromise;
  updateSaponinsSource: (
    args: {
      data: SaponinsSourceUpdateInput;
      where: SaponinsSourceWhereUniqueInput;
    }
  ) => SaponinsSourcePromise;
  updateManySaponinsSources: (
    args: {
      data: SaponinsSourceUpdateManyMutationInput;
      where?: SaponinsSourceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSaponinsSource: (
    args: {
      where: SaponinsSourceWhereUniqueInput;
      create: SaponinsSourceCreateInput;
      update: SaponinsSourceUpdateInput;
    }
  ) => SaponinsSourcePromise;
  deleteSaponinsSource: (
    where: SaponinsSourceWhereUniqueInput
  ) => SaponinsSourcePromise;
  deleteManySaponinsSources: (
    where?: SaponinsSourceWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  compound: (
    where?: CompoundSubscriptionWhereInput
  ) => CompoundSubscriptionPayloadSubscription;
  negativeMSData: (
    where?: NegativeMSDataSubscriptionWhereInput
  ) => NegativeMSDataSubscriptionPayloadSubscription;
  positiveMSData: (
    where?: PositiveMSDataSubscriptionWhereInput
  ) => PositiveMSDataSubscriptionPayloadSubscription;
  saponinsSource: (
    where?: SaponinsSourceSubscriptionWhereInput
  ) => SaponinsSourceSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CompoundOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "commonName_ASC"
  | "commonName_DESC"
  | "casCode_ASC"
  | "casCode_DESC"
  | "pubChemCID_ASC"
  | "pubChemCID_DESC"
  | "chemSpiderID_ASC"
  | "chemSpiderID_DESC"
  | "smiles_ASC"
  | "smiles_DESC"
  | "chemicalFormula_ASC"
  | "chemicalFormula_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NegativeMSDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "parentValue_ASC"
  | "parentValue_DESC"
  | "dataSource_ASC"
  | "dataSource_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PositiveMSDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "parentValue_ASC"
  | "parentValue_DESC"
  | "dataSource_ASC"
  | "dataSource_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SaponinsSourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RoleType = "ROOT" | "ADMIN" | "USER";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CompoundWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  smiles?: String;
}>;

export interface CompoundWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  commonName?: String;
  commonName_not?: String;
  commonName_in?: String[] | String;
  commonName_not_in?: String[] | String;
  commonName_lt?: String;
  commonName_lte?: String;
  commonName_gt?: String;
  commonName_gte?: String;
  commonName_contains?: String;
  commonName_not_contains?: String;
  commonName_starts_with?: String;
  commonName_not_starts_with?: String;
  commonName_ends_with?: String;
  commonName_not_ends_with?: String;
  casCode?: String;
  casCode_not?: String;
  casCode_in?: String[] | String;
  casCode_not_in?: String[] | String;
  casCode_lt?: String;
  casCode_lte?: String;
  casCode_gt?: String;
  casCode_gte?: String;
  casCode_contains?: String;
  casCode_not_contains?: String;
  casCode_starts_with?: String;
  casCode_not_starts_with?: String;
  casCode_ends_with?: String;
  casCode_not_ends_with?: String;
  pubChemCID?: String;
  pubChemCID_not?: String;
  pubChemCID_in?: String[] | String;
  pubChemCID_not_in?: String[] | String;
  pubChemCID_lt?: String;
  pubChemCID_lte?: String;
  pubChemCID_gt?: String;
  pubChemCID_gte?: String;
  pubChemCID_contains?: String;
  pubChemCID_not_contains?: String;
  pubChemCID_starts_with?: String;
  pubChemCID_not_starts_with?: String;
  pubChemCID_ends_with?: String;
  pubChemCID_not_ends_with?: String;
  chemSpiderID?: String;
  chemSpiderID_not?: String;
  chemSpiderID_in?: String[] | String;
  chemSpiderID_not_in?: String[] | String;
  chemSpiderID_lt?: String;
  chemSpiderID_lte?: String;
  chemSpiderID_gt?: String;
  chemSpiderID_gte?: String;
  chemSpiderID_contains?: String;
  chemSpiderID_not_contains?: String;
  chemSpiderID_starts_with?: String;
  chemSpiderID_not_starts_with?: String;
  chemSpiderID_ends_with?: String;
  chemSpiderID_not_ends_with?: String;
  smiles?: String;
  smiles_not?: String;
  smiles_in?: String[] | String;
  smiles_not_in?: String[] | String;
  smiles_lt?: String;
  smiles_lte?: String;
  smiles_gt?: String;
  smiles_gte?: String;
  smiles_contains?: String;
  smiles_not_contains?: String;
  smiles_starts_with?: String;
  smiles_not_starts_with?: String;
  smiles_ends_with?: String;
  smiles_not_ends_with?: String;
  chemicalFormula?: String;
  chemicalFormula_not?: String;
  chemicalFormula_in?: String[] | String;
  chemicalFormula_not_in?: String[] | String;
  chemicalFormula_lt?: String;
  chemicalFormula_lte?: String;
  chemicalFormula_gt?: String;
  chemicalFormula_gte?: String;
  chemicalFormula_contains?: String;
  chemicalFormula_not_contains?: String;
  chemicalFormula_starts_with?: String;
  chemicalFormula_not_starts_with?: String;
  chemicalFormula_ends_with?: String;
  chemicalFormula_not_ends_with?: String;
  positiveMSData?: PositiveMSDataWhereInput;
  negativeMSData?: NegativeMSDataWhereInput;
  saponinsSource?: SaponinsSourceWhereInput;
  AND?: CompoundWhereInput[] | CompoundWhereInput;
  OR?: CompoundWhereInput[] | CompoundWhereInput;
  NOT?: CompoundWhereInput[] | CompoundWhereInput;
}

export interface PositiveMSDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parentValue?: Float;
  parentValue_not?: Float;
  parentValue_in?: Float[] | Float;
  parentValue_not_in?: Float[] | Float;
  parentValue_lt?: Float;
  parentValue_lte?: Float;
  parentValue_gt?: Float;
  parentValue_gte?: Float;
  dataSource?: String;
  dataSource_not?: String;
  dataSource_in?: String[] | String;
  dataSource_not_in?: String[] | String;
  dataSource_lt?: String;
  dataSource_lte?: String;
  dataSource_gt?: String;
  dataSource_gte?: String;
  dataSource_contains?: String;
  dataSource_not_contains?: String;
  dataSource_starts_with?: String;
  dataSource_not_starts_with?: String;
  dataSource_ends_with?: String;
  dataSource_not_ends_with?: String;
  AND?: PositiveMSDataWhereInput[] | PositiveMSDataWhereInput;
  OR?: PositiveMSDataWhereInput[] | PositiveMSDataWhereInput;
  NOT?: PositiveMSDataWhereInput[] | PositiveMSDataWhereInput;
}

export interface NegativeMSDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parentValue?: Float;
  parentValue_not?: Float;
  parentValue_in?: Float[] | Float;
  parentValue_not_in?: Float[] | Float;
  parentValue_lt?: Float;
  parentValue_lte?: Float;
  parentValue_gt?: Float;
  parentValue_gte?: Float;
  dataSource?: String;
  dataSource_not?: String;
  dataSource_in?: String[] | String;
  dataSource_not_in?: String[] | String;
  dataSource_lt?: String;
  dataSource_lte?: String;
  dataSource_gt?: String;
  dataSource_gte?: String;
  dataSource_contains?: String;
  dataSource_not_contains?: String;
  dataSource_starts_with?: String;
  dataSource_not_starts_with?: String;
  dataSource_ends_with?: String;
  dataSource_not_ends_with?: String;
  AND?: NegativeMSDataWhereInput[] | NegativeMSDataWhereInput;
  OR?: NegativeMSDataWhereInput[] | NegativeMSDataWhereInput;
  NOT?: NegativeMSDataWhereInput[] | NegativeMSDataWhereInput;
}

export interface SaponinsSourceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: SaponinsSourceWhereInput[] | SaponinsSourceWhereInput;
  OR?: SaponinsSourceWhereInput[] | SaponinsSourceWhereInput;
  NOT?: SaponinsSourceWhereInput[] | SaponinsSourceWhereInput;
}

export type NegativeMSDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PositiveMSDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SaponinsSourceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  role?: RoleType;
  role_not?: RoleType;
  role_in?: RoleType[] | RoleType;
  role_not_in?: RoleType[] | RoleType;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CompoundCreateInput {
  commonName: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
  smiles: String;
  chemicalFormula?: String;
  positiveMSData?: PositiveMSDataCreateOneInput;
  negativeMSData?: NegativeMSDataCreateOneInput;
  saponinsSource?: SaponinsSourceCreateOneInput;
}

export interface PositiveMSDataCreateOneInput {
  create?: PositiveMSDataCreateInput;
  connect?: PositiveMSDataWhereUniqueInput;
}

export interface PositiveMSDataCreateInput {
  parentValue: Float;
  fragmentsValues?: PositiveMSDataCreatefragmentsValuesInput;
  dataSource?: String;
  referenceCodes?: PositiveMSDataCreatereferenceCodesInput;
}

export interface PositiveMSDataCreatefragmentsValuesInput {
  set?: Float[] | Float;
}

export interface PositiveMSDataCreatereferenceCodesInput {
  set?: String[] | String;
}

export interface NegativeMSDataCreateOneInput {
  create?: NegativeMSDataCreateInput;
  connect?: NegativeMSDataWhereUniqueInput;
}

export interface NegativeMSDataCreateInput {
  parentValue: Float;
  fragmentsValues?: NegativeMSDataCreatefragmentsValuesInput;
  dataSource?: String;
  referenceCodes?: NegativeMSDataCreatereferenceCodesInput;
}

export interface NegativeMSDataCreatefragmentsValuesInput {
  set?: Float[] | Float;
}

export interface NegativeMSDataCreatereferenceCodesInput {
  set?: String[] | String;
}

export interface SaponinsSourceCreateOneInput {
  create?: SaponinsSourceCreateInput;
  connect?: SaponinsSourceWhereUniqueInput;
}

export interface SaponinsSourceCreateInput {
  sourceCodes?: SaponinsSourceCreatesourceCodesInput;
}

export interface SaponinsSourceCreatesourceCodesInput {
  set?: String[] | String;
}

export interface CompoundUpdateInput {
  commonName?: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
  smiles?: String;
  chemicalFormula?: String;
  positiveMSData?: PositiveMSDataUpdateOneInput;
  negativeMSData?: NegativeMSDataUpdateOneInput;
  saponinsSource?: SaponinsSourceUpdateOneInput;
}

export interface PositiveMSDataUpdateOneInput {
  create?: PositiveMSDataCreateInput;
  update?: PositiveMSDataUpdateDataInput;
  upsert?: PositiveMSDataUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PositiveMSDataWhereUniqueInput;
}

export interface PositiveMSDataUpdateDataInput {
  parentValue?: Float;
  fragmentsValues?: PositiveMSDataUpdatefragmentsValuesInput;
  dataSource?: String;
  referenceCodes?: PositiveMSDataUpdatereferenceCodesInput;
}

export interface PositiveMSDataUpdatefragmentsValuesInput {
  set?: Float[] | Float;
}

export interface PositiveMSDataUpdatereferenceCodesInput {
  set?: String[] | String;
}

export interface PositiveMSDataUpsertNestedInput {
  update: PositiveMSDataUpdateDataInput;
  create: PositiveMSDataCreateInput;
}

export interface NegativeMSDataUpdateOneInput {
  create?: NegativeMSDataCreateInput;
  update?: NegativeMSDataUpdateDataInput;
  upsert?: NegativeMSDataUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: NegativeMSDataWhereUniqueInput;
}

export interface NegativeMSDataUpdateDataInput {
  parentValue?: Float;
  fragmentsValues?: NegativeMSDataUpdatefragmentsValuesInput;
  dataSource?: String;
  referenceCodes?: NegativeMSDataUpdatereferenceCodesInput;
}

export interface NegativeMSDataUpdatefragmentsValuesInput {
  set?: Float[] | Float;
}

export interface NegativeMSDataUpdatereferenceCodesInput {
  set?: String[] | String;
}

export interface NegativeMSDataUpsertNestedInput {
  update: NegativeMSDataUpdateDataInput;
  create: NegativeMSDataCreateInput;
}

export interface SaponinsSourceUpdateOneInput {
  create?: SaponinsSourceCreateInput;
  update?: SaponinsSourceUpdateDataInput;
  upsert?: SaponinsSourceUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SaponinsSourceWhereUniqueInput;
}

export interface SaponinsSourceUpdateDataInput {
  sourceCodes?: SaponinsSourceUpdatesourceCodesInput;
}

export interface SaponinsSourceUpdatesourceCodesInput {
  set?: String[] | String;
}

export interface SaponinsSourceUpsertNestedInput {
  update: SaponinsSourceUpdateDataInput;
  create: SaponinsSourceCreateInput;
}

export interface CompoundUpdateManyMutationInput {
  commonName?: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
  smiles?: String;
  chemicalFormula?: String;
}

export interface NegativeMSDataUpdateInput {
  parentValue?: Float;
  fragmentsValues?: NegativeMSDataUpdatefragmentsValuesInput;
  dataSource?: String;
  referenceCodes?: NegativeMSDataUpdatereferenceCodesInput;
}

export interface NegativeMSDataUpdateManyMutationInput {
  parentValue?: Float;
  fragmentsValues?: NegativeMSDataUpdatefragmentsValuesInput;
  dataSource?: String;
  referenceCodes?: NegativeMSDataUpdatereferenceCodesInput;
}

export interface PositiveMSDataUpdateInput {
  parentValue?: Float;
  fragmentsValues?: PositiveMSDataUpdatefragmentsValuesInput;
  dataSource?: String;
  referenceCodes?: PositiveMSDataUpdatereferenceCodesInput;
}

export interface PositiveMSDataUpdateManyMutationInput {
  parentValue?: Float;
  fragmentsValues?: PositiveMSDataUpdatefragmentsValuesInput;
  dataSource?: String;
  referenceCodes?: PositiveMSDataUpdatereferenceCodesInput;
}

export interface SaponinsSourceUpdateInput {
  sourceCodes?: SaponinsSourceUpdatesourceCodesInput;
}

export interface SaponinsSourceUpdateManyMutationInput {
  sourceCodes?: SaponinsSourceUpdatesourceCodesInput;
}

export interface UserCreateInput {
  name?: String;
  email: String;
  password: String;
  role?: RoleType;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  role?: RoleType;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
  role?: RoleType;
}

export interface CompoundSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompoundWhereInput;
  AND?: CompoundSubscriptionWhereInput[] | CompoundSubscriptionWhereInput;
  OR?: CompoundSubscriptionWhereInput[] | CompoundSubscriptionWhereInput;
  NOT?: CompoundSubscriptionWhereInput[] | CompoundSubscriptionWhereInput;
}

export interface NegativeMSDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NegativeMSDataWhereInput;
  AND?:
    | NegativeMSDataSubscriptionWhereInput[]
    | NegativeMSDataSubscriptionWhereInput;
  OR?:
    | NegativeMSDataSubscriptionWhereInput[]
    | NegativeMSDataSubscriptionWhereInput;
  NOT?:
    | NegativeMSDataSubscriptionWhereInput[]
    | NegativeMSDataSubscriptionWhereInput;
}

export interface PositiveMSDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PositiveMSDataWhereInput;
  AND?:
    | PositiveMSDataSubscriptionWhereInput[]
    | PositiveMSDataSubscriptionWhereInput;
  OR?:
    | PositiveMSDataSubscriptionWhereInput[]
    | PositiveMSDataSubscriptionWhereInput;
  NOT?:
    | PositiveMSDataSubscriptionWhereInput[]
    | PositiveMSDataSubscriptionWhereInput;
}

export interface SaponinsSourceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SaponinsSourceWhereInput;
  AND?:
    | SaponinsSourceSubscriptionWhereInput[]
    | SaponinsSourceSubscriptionWhereInput;
  OR?:
    | SaponinsSourceSubscriptionWhereInput[]
    | SaponinsSourceSubscriptionWhereInput;
  NOT?:
    | SaponinsSourceSubscriptionWhereInput[]
    | SaponinsSourceSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Compound {
  id: ID_Output;
  commonName: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
  smiles: String;
  chemicalFormula?: String;
}

export interface CompoundPromise extends Promise<Compound>, Fragmentable {
  id: () => Promise<ID_Output>;
  commonName: () => Promise<String>;
  casCode: () => Promise<String>;
  pubChemCID: () => Promise<String>;
  chemSpiderID: () => Promise<String>;
  smiles: () => Promise<String>;
  chemicalFormula: () => Promise<String>;
  positiveMSData: <T = PositiveMSDataPromise>() => T;
  negativeMSData: <T = NegativeMSDataPromise>() => T;
  saponinsSource: <T = SaponinsSourcePromise>() => T;
}

export interface CompoundSubscription
  extends Promise<AsyncIterator<Compound>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  commonName: () => Promise<AsyncIterator<String>>;
  casCode: () => Promise<AsyncIterator<String>>;
  pubChemCID: () => Promise<AsyncIterator<String>>;
  chemSpiderID: () => Promise<AsyncIterator<String>>;
  smiles: () => Promise<AsyncIterator<String>>;
  chemicalFormula: () => Promise<AsyncIterator<String>>;
  positiveMSData: <T = PositiveMSDataSubscription>() => T;
  negativeMSData: <T = NegativeMSDataSubscription>() => T;
  saponinsSource: <T = SaponinsSourceSubscription>() => T;
}

export interface PositiveMSData {
  id: ID_Output;
  parentValue: Float;
  fragmentsValues: Float[];
  dataSource?: String;
  referenceCodes: String[];
}

export interface PositiveMSDataPromise
  extends Promise<PositiveMSData>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentValue: () => Promise<Float>;
  fragmentsValues: () => Promise<Float[]>;
  dataSource: () => Promise<String>;
  referenceCodes: () => Promise<String[]>;
}

export interface PositiveMSDataSubscription
  extends Promise<AsyncIterator<PositiveMSData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentValue: () => Promise<AsyncIterator<Float>>;
  fragmentsValues: () => Promise<AsyncIterator<Float[]>>;
  dataSource: () => Promise<AsyncIterator<String>>;
  referenceCodes: () => Promise<AsyncIterator<String[]>>;
}

export interface NegativeMSData {
  id: ID_Output;
  parentValue: Float;
  fragmentsValues: Float[];
  dataSource?: String;
  referenceCodes: String[];
}

export interface NegativeMSDataPromise
  extends Promise<NegativeMSData>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentValue: () => Promise<Float>;
  fragmentsValues: () => Promise<Float[]>;
  dataSource: () => Promise<String>;
  referenceCodes: () => Promise<String[]>;
}

export interface NegativeMSDataSubscription
  extends Promise<AsyncIterator<NegativeMSData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentValue: () => Promise<AsyncIterator<Float>>;
  fragmentsValues: () => Promise<AsyncIterator<Float[]>>;
  dataSource: () => Promise<AsyncIterator<String>>;
  referenceCodes: () => Promise<AsyncIterator<String[]>>;
}

export interface SaponinsSource {
  id: ID_Output;
  sourceCodes: String[];
}

export interface SaponinsSourcePromise
  extends Promise<SaponinsSource>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sourceCodes: () => Promise<String[]>;
}

export interface SaponinsSourceSubscription
  extends Promise<AsyncIterator<SaponinsSource>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sourceCodes: () => Promise<AsyncIterator<String[]>>;
}

export interface CompoundConnection {
  pageInfo: PageInfo;
  edges: CompoundEdge[];
}

export interface CompoundConnectionPromise
  extends Promise<CompoundConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompoundEdge>>() => T;
  aggregate: <T = AggregateCompoundPromise>() => T;
}

export interface CompoundConnectionSubscription
  extends Promise<AsyncIterator<CompoundConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompoundEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompoundSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CompoundEdge {
  node: Compound;
  cursor: String;
}

export interface CompoundEdgePromise
  extends Promise<CompoundEdge>,
    Fragmentable {
  node: <T = CompoundPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompoundEdgeSubscription
  extends Promise<AsyncIterator<CompoundEdge>>,
    Fragmentable {
  node: <T = CompoundSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompound {
  count: Int;
}

export interface AggregateCompoundPromise
  extends Promise<AggregateCompound>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompoundSubscription
  extends Promise<AsyncIterator<AggregateCompound>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NegativeMSDataConnection {
  pageInfo: PageInfo;
  edges: NegativeMSDataEdge[];
}

export interface NegativeMSDataConnectionPromise
  extends Promise<NegativeMSDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NegativeMSDataEdge>>() => T;
  aggregate: <T = AggregateNegativeMSDataPromise>() => T;
}

export interface NegativeMSDataConnectionSubscription
  extends Promise<AsyncIterator<NegativeMSDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NegativeMSDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNegativeMSDataSubscription>() => T;
}

export interface NegativeMSDataEdge {
  node: NegativeMSData;
  cursor: String;
}

export interface NegativeMSDataEdgePromise
  extends Promise<NegativeMSDataEdge>,
    Fragmentable {
  node: <T = NegativeMSDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NegativeMSDataEdgeSubscription
  extends Promise<AsyncIterator<NegativeMSDataEdge>>,
    Fragmentable {
  node: <T = NegativeMSDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNegativeMSData {
  count: Int;
}

export interface AggregateNegativeMSDataPromise
  extends Promise<AggregateNegativeMSData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNegativeMSDataSubscription
  extends Promise<AsyncIterator<AggregateNegativeMSData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PositiveMSDataConnection {
  pageInfo: PageInfo;
  edges: PositiveMSDataEdge[];
}

export interface PositiveMSDataConnectionPromise
  extends Promise<PositiveMSDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PositiveMSDataEdge>>() => T;
  aggregate: <T = AggregatePositiveMSDataPromise>() => T;
}

export interface PositiveMSDataConnectionSubscription
  extends Promise<AsyncIterator<PositiveMSDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PositiveMSDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePositiveMSDataSubscription>() => T;
}

export interface PositiveMSDataEdge {
  node: PositiveMSData;
  cursor: String;
}

export interface PositiveMSDataEdgePromise
  extends Promise<PositiveMSDataEdge>,
    Fragmentable {
  node: <T = PositiveMSDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PositiveMSDataEdgeSubscription
  extends Promise<AsyncIterator<PositiveMSDataEdge>>,
    Fragmentable {
  node: <T = PositiveMSDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePositiveMSData {
  count: Int;
}

export interface AggregatePositiveMSDataPromise
  extends Promise<AggregatePositiveMSData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePositiveMSDataSubscription
  extends Promise<AsyncIterator<AggregatePositiveMSData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SaponinsSourceConnection {
  pageInfo: PageInfo;
  edges: SaponinsSourceEdge[];
}

export interface SaponinsSourceConnectionPromise
  extends Promise<SaponinsSourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SaponinsSourceEdge>>() => T;
  aggregate: <T = AggregateSaponinsSourcePromise>() => T;
}

export interface SaponinsSourceConnectionSubscription
  extends Promise<AsyncIterator<SaponinsSourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SaponinsSourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSaponinsSourceSubscription>() => T;
}

export interface SaponinsSourceEdge {
  node: SaponinsSource;
  cursor: String;
}

export interface SaponinsSourceEdgePromise
  extends Promise<SaponinsSourceEdge>,
    Fragmentable {
  node: <T = SaponinsSourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SaponinsSourceEdgeSubscription
  extends Promise<AsyncIterator<SaponinsSourceEdge>>,
    Fragmentable {
  node: <T = SaponinsSourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSaponinsSource {
  count: Int;
}

export interface AggregateSaponinsSourcePromise
  extends Promise<AggregateSaponinsSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSaponinsSourceSubscription
  extends Promise<AsyncIterator<AggregateSaponinsSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name?: String;
  email: String;
  password: String;
  role: RoleType;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<RoleType>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<RoleType>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CompoundSubscriptionPayload {
  mutation: MutationType;
  node: Compound;
  updatedFields: String[];
  previousValues: CompoundPreviousValues;
}

export interface CompoundSubscriptionPayloadPromise
  extends Promise<CompoundSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompoundPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompoundPreviousValuesPromise>() => T;
}

export interface CompoundSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompoundSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompoundSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompoundPreviousValuesSubscription>() => T;
}

export interface CompoundPreviousValues {
  id: ID_Output;
  commonName: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
  smiles: String;
  chemicalFormula?: String;
}

export interface CompoundPreviousValuesPromise
  extends Promise<CompoundPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  commonName: () => Promise<String>;
  casCode: () => Promise<String>;
  pubChemCID: () => Promise<String>;
  chemSpiderID: () => Promise<String>;
  smiles: () => Promise<String>;
  chemicalFormula: () => Promise<String>;
}

export interface CompoundPreviousValuesSubscription
  extends Promise<AsyncIterator<CompoundPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  commonName: () => Promise<AsyncIterator<String>>;
  casCode: () => Promise<AsyncIterator<String>>;
  pubChemCID: () => Promise<AsyncIterator<String>>;
  chemSpiderID: () => Promise<AsyncIterator<String>>;
  smiles: () => Promise<AsyncIterator<String>>;
  chemicalFormula: () => Promise<AsyncIterator<String>>;
}

export interface NegativeMSDataSubscriptionPayload {
  mutation: MutationType;
  node: NegativeMSData;
  updatedFields: String[];
  previousValues: NegativeMSDataPreviousValues;
}

export interface NegativeMSDataSubscriptionPayloadPromise
  extends Promise<NegativeMSDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NegativeMSDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NegativeMSDataPreviousValuesPromise>() => T;
}

export interface NegativeMSDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NegativeMSDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NegativeMSDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NegativeMSDataPreviousValuesSubscription>() => T;
}

export interface NegativeMSDataPreviousValues {
  id: ID_Output;
  parentValue: Float;
  fragmentsValues: Float[];
  dataSource?: String;
  referenceCodes: String[];
}

export interface NegativeMSDataPreviousValuesPromise
  extends Promise<NegativeMSDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentValue: () => Promise<Float>;
  fragmentsValues: () => Promise<Float[]>;
  dataSource: () => Promise<String>;
  referenceCodes: () => Promise<String[]>;
}

export interface NegativeMSDataPreviousValuesSubscription
  extends Promise<AsyncIterator<NegativeMSDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentValue: () => Promise<AsyncIterator<Float>>;
  fragmentsValues: () => Promise<AsyncIterator<Float[]>>;
  dataSource: () => Promise<AsyncIterator<String>>;
  referenceCodes: () => Promise<AsyncIterator<String[]>>;
}

export interface PositiveMSDataSubscriptionPayload {
  mutation: MutationType;
  node: PositiveMSData;
  updatedFields: String[];
  previousValues: PositiveMSDataPreviousValues;
}

export interface PositiveMSDataSubscriptionPayloadPromise
  extends Promise<PositiveMSDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PositiveMSDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PositiveMSDataPreviousValuesPromise>() => T;
}

export interface PositiveMSDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PositiveMSDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PositiveMSDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PositiveMSDataPreviousValuesSubscription>() => T;
}

export interface PositiveMSDataPreviousValues {
  id: ID_Output;
  parentValue: Float;
  fragmentsValues: Float[];
  dataSource?: String;
  referenceCodes: String[];
}

export interface PositiveMSDataPreviousValuesPromise
  extends Promise<PositiveMSDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentValue: () => Promise<Float>;
  fragmentsValues: () => Promise<Float[]>;
  dataSource: () => Promise<String>;
  referenceCodes: () => Promise<String[]>;
}

export interface PositiveMSDataPreviousValuesSubscription
  extends Promise<AsyncIterator<PositiveMSDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentValue: () => Promise<AsyncIterator<Float>>;
  fragmentsValues: () => Promise<AsyncIterator<Float[]>>;
  dataSource: () => Promise<AsyncIterator<String>>;
  referenceCodes: () => Promise<AsyncIterator<String[]>>;
}

export interface SaponinsSourceSubscriptionPayload {
  mutation: MutationType;
  node: SaponinsSource;
  updatedFields: String[];
  previousValues: SaponinsSourcePreviousValues;
}

export interface SaponinsSourceSubscriptionPayloadPromise
  extends Promise<SaponinsSourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SaponinsSourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SaponinsSourcePreviousValuesPromise>() => T;
}

export interface SaponinsSourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SaponinsSourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SaponinsSourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SaponinsSourcePreviousValuesSubscription>() => T;
}

export interface SaponinsSourcePreviousValues {
  id: ID_Output;
  sourceCodes: String[];
}

export interface SaponinsSourcePreviousValuesPromise
  extends Promise<SaponinsSourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sourceCodes: () => Promise<String[]>;
}

export interface SaponinsSourcePreviousValuesSubscription
  extends Promise<AsyncIterator<SaponinsSourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sourceCodes: () => Promise<AsyncIterator<String[]>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name?: String;
  email: String;
  password: String;
  role: RoleType;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<RoleType>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<RoleType>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Compound",
    embedded: false
  },
  {
    name: "PositiveMSData",
    embedded: false
  },
  {
    name: "NegativeMSData",
    embedded: false
  },
  {
    name: "SaponinsSource",
    embedded: false
  },
  {
    name: "RoleType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
