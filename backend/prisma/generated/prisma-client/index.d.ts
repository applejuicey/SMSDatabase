// Code generated by Prisma (prisma@1.26.6). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  compound: (where?: CompoundWhereInput) => Promise<boolean>;
  literatureSource: (where?: LiteratureSourceWhereInput) => Promise<boolean>;
  mSData: (where?: MSDataWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  compound: (where: CompoundWhereUniqueInput) => CompoundPromise;
  compounds: (args?: {
    where?: CompoundWhereInput;
    orderBy?: CompoundOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Compound>;
  compoundsConnection: (args?: {
    where?: CompoundWhereInput;
    orderBy?: CompoundOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompoundConnectionPromise;
  literatureSource: (
    where: LiteratureSourceWhereUniqueInput
  ) => LiteratureSourcePromise;
  literatureSources: (args?: {
    where?: LiteratureSourceWhereInput;
    orderBy?: LiteratureSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LiteratureSource>;
  literatureSourcesConnection: (args?: {
    where?: LiteratureSourceWhereInput;
    orderBy?: LiteratureSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LiteratureSourceConnectionPromise;
  mSData: (where: MSDataWhereUniqueInput) => MSDataPromise;
  mSDatas: (args?: {
    where?: MSDataWhereInput;
    orderBy?: MSDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MSData>;
  mSDatasConnection: (args?: {
    where?: MSDataWhereInput;
    orderBy?: MSDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MSDataConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCompound: (data: CompoundCreateInput) => CompoundPromise;
  updateCompound: (args: {
    data: CompoundUpdateInput;
    where: CompoundWhereUniqueInput;
  }) => CompoundPromise;
  updateManyCompounds: (args: {
    data: CompoundUpdateManyMutationInput;
    where?: CompoundWhereInput;
  }) => BatchPayloadPromise;
  upsertCompound: (args: {
    where: CompoundWhereUniqueInput;
    create: CompoundCreateInput;
    update: CompoundUpdateInput;
  }) => CompoundPromise;
  deleteCompound: (where: CompoundWhereUniqueInput) => CompoundPromise;
  deleteManyCompounds: (where?: CompoundWhereInput) => BatchPayloadPromise;
  createLiteratureSource: (
    data: LiteratureSourceCreateInput
  ) => LiteratureSourcePromise;
  updateLiteratureSource: (args: {
    data: LiteratureSourceUpdateInput;
    where: LiteratureSourceWhereUniqueInput;
  }) => LiteratureSourcePromise;
  updateManyLiteratureSources: (args: {
    data: LiteratureSourceUpdateManyMutationInput;
    where?: LiteratureSourceWhereInput;
  }) => BatchPayloadPromise;
  upsertLiteratureSource: (args: {
    where: LiteratureSourceWhereUniqueInput;
    create: LiteratureSourceCreateInput;
    update: LiteratureSourceUpdateInput;
  }) => LiteratureSourcePromise;
  deleteLiteratureSource: (
    where: LiteratureSourceWhereUniqueInput
  ) => LiteratureSourcePromise;
  deleteManyLiteratureSources: (
    where?: LiteratureSourceWhereInput
  ) => BatchPayloadPromise;
  createMSData: (data: MSDataCreateInput) => MSDataPromise;
  updateMSData: (args: {
    data: MSDataUpdateInput;
    where: MSDataWhereUniqueInput;
  }) => MSDataPromise;
  updateManyMSDatas: (args: {
    data: MSDataUpdateManyMutationInput;
    where?: MSDataWhereInput;
  }) => BatchPayloadPromise;
  upsertMSData: (args: {
    where: MSDataWhereUniqueInput;
    create: MSDataCreateInput;
    update: MSDataUpdateInput;
  }) => MSDataPromise;
  deleteMSData: (where: MSDataWhereUniqueInput) => MSDataPromise;
  deleteManyMSDatas: (where?: MSDataWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  compound: (
    where?: CompoundSubscriptionWhereInput
  ) => CompoundSubscriptionPayloadSubscription;
  literatureSource: (
    where?: LiteratureSourceSubscriptionWhereInput
  ) => LiteratureSourceSubscriptionPayloadSubscription;
  mSData: (
    where?: MSDataSubscriptionWhereInput
  ) => MSDataSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CompoundOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "uniqueID_ASC"
  | "uniqueID_DESC"
  | "commonName_ASC"
  | "commonName_DESC"
  | "smiles_ASC"
  | "smiles_DESC"
  | "chemicalFormula_ASC"
  | "chemicalFormula_DESC"
  | "structurePicAdd_ASC"
  | "structurePicAdd_DESC"
  | "casCode_ASC"
  | "casCode_DESC"
  | "pubChemCID_ASC"
  | "pubChemCID_DESC"
  | "chemSpiderID_ASC"
  | "chemSpiderID_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LiteratureSourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MSDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "parentValue1_ASC"
  | "parentValue1_DESC"
  | "parentValue2_ASC"
  | "parentValue2_DESC"
  | "parentValue3_ASC"
  | "parentValue3_DESC"
  | "parentValue4_ASC"
  | "parentValue4_DESC"
  | "parentValue5_ASC"
  | "parentValue5_DESC"
  | "parentValue6_ASC"
  | "parentValue6_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RoleType = "ROOT" | "ADMIN" | "USER";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CompoundWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  uniqueID?: String;
  commonName?: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
}>;

export interface CompoundWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  uniqueID?: String;
  uniqueID_not?: String;
  uniqueID_in?: String[] | String;
  uniqueID_not_in?: String[] | String;
  uniqueID_lt?: String;
  uniqueID_lte?: String;
  uniqueID_gt?: String;
  uniqueID_gte?: String;
  uniqueID_contains?: String;
  uniqueID_not_contains?: String;
  uniqueID_starts_with?: String;
  uniqueID_not_starts_with?: String;
  uniqueID_ends_with?: String;
  uniqueID_not_ends_with?: String;
  commonName?: String;
  commonName_not?: String;
  commonName_in?: String[] | String;
  commonName_not_in?: String[] | String;
  commonName_lt?: String;
  commonName_lte?: String;
  commonName_gt?: String;
  commonName_gte?: String;
  commonName_contains?: String;
  commonName_not_contains?: String;
  commonName_starts_with?: String;
  commonName_not_starts_with?: String;
  commonName_ends_with?: String;
  commonName_not_ends_with?: String;
  smiles?: String;
  smiles_not?: String;
  smiles_in?: String[] | String;
  smiles_not_in?: String[] | String;
  smiles_lt?: String;
  smiles_lte?: String;
  smiles_gt?: String;
  smiles_gte?: String;
  smiles_contains?: String;
  smiles_not_contains?: String;
  smiles_starts_with?: String;
  smiles_not_starts_with?: String;
  smiles_ends_with?: String;
  smiles_not_ends_with?: String;
  chemicalFormula?: String;
  chemicalFormula_not?: String;
  chemicalFormula_in?: String[] | String;
  chemicalFormula_not_in?: String[] | String;
  chemicalFormula_lt?: String;
  chemicalFormula_lte?: String;
  chemicalFormula_gt?: String;
  chemicalFormula_gte?: String;
  chemicalFormula_contains?: String;
  chemicalFormula_not_contains?: String;
  chemicalFormula_starts_with?: String;
  chemicalFormula_not_starts_with?: String;
  chemicalFormula_ends_with?: String;
  chemicalFormula_not_ends_with?: String;
  structurePicAdd?: String;
  structurePicAdd_not?: String;
  structurePicAdd_in?: String[] | String;
  structurePicAdd_not_in?: String[] | String;
  structurePicAdd_lt?: String;
  structurePicAdd_lte?: String;
  structurePicAdd_gt?: String;
  structurePicAdd_gte?: String;
  structurePicAdd_contains?: String;
  structurePicAdd_not_contains?: String;
  structurePicAdd_starts_with?: String;
  structurePicAdd_not_starts_with?: String;
  structurePicAdd_ends_with?: String;
  structurePicAdd_not_ends_with?: String;
  casCode?: String;
  casCode_not?: String;
  casCode_in?: String[] | String;
  casCode_not_in?: String[] | String;
  casCode_lt?: String;
  casCode_lte?: String;
  casCode_gt?: String;
  casCode_gte?: String;
  casCode_contains?: String;
  casCode_not_contains?: String;
  casCode_starts_with?: String;
  casCode_not_starts_with?: String;
  casCode_ends_with?: String;
  casCode_not_ends_with?: String;
  pubChemCID?: String;
  pubChemCID_not?: String;
  pubChemCID_in?: String[] | String;
  pubChemCID_not_in?: String[] | String;
  pubChemCID_lt?: String;
  pubChemCID_lte?: String;
  pubChemCID_gt?: String;
  pubChemCID_gte?: String;
  pubChemCID_contains?: String;
  pubChemCID_not_contains?: String;
  pubChemCID_starts_with?: String;
  pubChemCID_not_starts_with?: String;
  pubChemCID_ends_with?: String;
  pubChemCID_not_ends_with?: String;
  chemSpiderID?: String;
  chemSpiderID_not?: String;
  chemSpiderID_in?: String[] | String;
  chemSpiderID_not_in?: String[] | String;
  chemSpiderID_lt?: String;
  chemSpiderID_lte?: String;
  chemSpiderID_gt?: String;
  chemSpiderID_gte?: String;
  chemSpiderID_contains?: String;
  chemSpiderID_not_contains?: String;
  chemSpiderID_starts_with?: String;
  chemSpiderID_not_starts_with?: String;
  chemSpiderID_ends_with?: String;
  chemSpiderID_not_ends_with?: String;
  msData?: MSDataWhereInput;
  literatureSource?: LiteratureSourceWhereInput;
  AND?: CompoundWhereInput[] | CompoundWhereInput;
  OR?: CompoundWhereInput[] | CompoundWhereInput;
  NOT?: CompoundWhereInput[] | CompoundWhereInput;
}

export interface MSDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parentValue1?: Float;
  parentValue1_not?: Float;
  parentValue1_in?: Float[] | Float;
  parentValue1_not_in?: Float[] | Float;
  parentValue1_lt?: Float;
  parentValue1_lte?: Float;
  parentValue1_gt?: Float;
  parentValue1_gte?: Float;
  parentValue2?: Float;
  parentValue2_not?: Float;
  parentValue2_in?: Float[] | Float;
  parentValue2_not_in?: Float[] | Float;
  parentValue2_lt?: Float;
  parentValue2_lte?: Float;
  parentValue2_gt?: Float;
  parentValue2_gte?: Float;
  parentValue3?: Float;
  parentValue3_not?: Float;
  parentValue3_in?: Float[] | Float;
  parentValue3_not_in?: Float[] | Float;
  parentValue3_lt?: Float;
  parentValue3_lte?: Float;
  parentValue3_gt?: Float;
  parentValue3_gte?: Float;
  parentValue4?: Float;
  parentValue4_not?: Float;
  parentValue4_in?: Float[] | Float;
  parentValue4_not_in?: Float[] | Float;
  parentValue4_lt?: Float;
  parentValue4_lte?: Float;
  parentValue4_gt?: Float;
  parentValue4_gte?: Float;
  parentValue5?: Float;
  parentValue5_not?: Float;
  parentValue5_in?: Float[] | Float;
  parentValue5_not_in?: Float[] | Float;
  parentValue5_lt?: Float;
  parentValue5_lte?: Float;
  parentValue5_gt?: Float;
  parentValue5_gte?: Float;
  parentValue6?: Float;
  parentValue6_not?: Float;
  parentValue6_in?: Float[] | Float;
  parentValue6_not_in?: Float[] | Float;
  parentValue6_lt?: Float;
  parentValue6_lte?: Float;
  parentValue6_gt?: Float;
  parentValue6_gte?: Float;
  AND?: MSDataWhereInput[] | MSDataWhereInput;
  OR?: MSDataWhereInput[] | MSDataWhereInput;
  NOT?: MSDataWhereInput[] | MSDataWhereInput;
}

export interface LiteratureSourceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: LiteratureSourceWhereInput[] | LiteratureSourceWhereInput;
  OR?: LiteratureSourceWhereInput[] | LiteratureSourceWhereInput;
  NOT?: LiteratureSourceWhereInput[] | LiteratureSourceWhereInput;
}

export type LiteratureSourceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MSDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  role?: RoleType;
  role_not?: RoleType;
  role_in?: RoleType[] | RoleType;
  role_not_in?: RoleType[] | RoleType;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CompoundCreateInput {
  uniqueID: String;
  commonName: String;
  smiles: String;
  chemicalFormula: String;
  structurePicAdd?: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
  msData: MSDataCreateOneInput;
  literatureSource: LiteratureSourceCreateOneInput;
}

export interface MSDataCreateOneInput {
  create?: MSDataCreateInput;
  connect?: MSDataWhereUniqueInput;
}

export interface MSDataCreateInput {
  parentValue1?: Float;
  parentValue2?: Float;
  parentValue3?: Float;
  parentValue4?: Float;
  parentValue5?: Float;
  parentValue6?: Float;
  fragmentsValues1?: MSDataCreatefragmentsValues1Input;
  fragmentsValues2?: MSDataCreatefragmentsValues2Input;
  dataSource1?: MSDataCreatedataSource1Input;
  referenceCodes1?: MSDataCreatereferenceCodes1Input;
  dataSource2?: MSDataCreatedataSource2Input;
  referenceCodes2?: MSDataCreatereferenceCodes2Input;
  spectrumPicAddArray1?: MSDataCreatespectrumPicAddArray1Input;
  spectrumPicAddArray2?: MSDataCreatespectrumPicAddArray2Input;
}

export interface MSDataCreatefragmentsValues1Input {
  set?: Float[] | Float;
}

export interface MSDataCreatefragmentsValues2Input {
  set?: Float[] | Float;
}

export interface MSDataCreatedataSource1Input {
  set?: String[] | String;
}

export interface MSDataCreatereferenceCodes1Input {
  set?: String[] | String;
}

export interface MSDataCreatedataSource2Input {
  set?: String[] | String;
}

export interface MSDataCreatereferenceCodes2Input {
  set?: String[] | String;
}

export interface MSDataCreatespectrumPicAddArray1Input {
  set?: String[] | String;
}

export interface MSDataCreatespectrumPicAddArray2Input {
  set?: String[] | String;
}

export interface LiteratureSourceCreateOneInput {
  create?: LiteratureSourceCreateInput;
  connect?: LiteratureSourceWhereUniqueInput;
}

export interface LiteratureSourceCreateInput {
  sourceCodes?: LiteratureSourceCreatesourceCodesInput;
}

export interface LiteratureSourceCreatesourceCodesInput {
  set?: String[] | String;
}

export interface CompoundUpdateInput {
  uniqueID?: String;
  commonName?: String;
  smiles?: String;
  chemicalFormula?: String;
  structurePicAdd?: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
  msData?: MSDataUpdateOneRequiredInput;
  literatureSource?: LiteratureSourceUpdateOneRequiredInput;
}

export interface MSDataUpdateOneRequiredInput {
  create?: MSDataCreateInput;
  update?: MSDataUpdateDataInput;
  upsert?: MSDataUpsertNestedInput;
  connect?: MSDataWhereUniqueInput;
}

export interface MSDataUpdateDataInput {
  parentValue1?: Float;
  parentValue2?: Float;
  parentValue3?: Float;
  parentValue4?: Float;
  parentValue5?: Float;
  parentValue6?: Float;
  fragmentsValues1?: MSDataUpdatefragmentsValues1Input;
  fragmentsValues2?: MSDataUpdatefragmentsValues2Input;
  dataSource1?: MSDataUpdatedataSource1Input;
  referenceCodes1?: MSDataUpdatereferenceCodes1Input;
  dataSource2?: MSDataUpdatedataSource2Input;
  referenceCodes2?: MSDataUpdatereferenceCodes2Input;
  spectrumPicAddArray1?: MSDataUpdatespectrumPicAddArray1Input;
  spectrumPicAddArray2?: MSDataUpdatespectrumPicAddArray2Input;
}

export interface MSDataUpdatefragmentsValues1Input {
  set?: Float[] | Float;
}

export interface MSDataUpdatefragmentsValues2Input {
  set?: Float[] | Float;
}

export interface MSDataUpdatedataSource1Input {
  set?: String[] | String;
}

export interface MSDataUpdatereferenceCodes1Input {
  set?: String[] | String;
}

export interface MSDataUpdatedataSource2Input {
  set?: String[] | String;
}

export interface MSDataUpdatereferenceCodes2Input {
  set?: String[] | String;
}

export interface MSDataUpdatespectrumPicAddArray1Input {
  set?: String[] | String;
}

export interface MSDataUpdatespectrumPicAddArray2Input {
  set?: String[] | String;
}

export interface MSDataUpsertNestedInput {
  update: MSDataUpdateDataInput;
  create: MSDataCreateInput;
}

export interface LiteratureSourceUpdateOneRequiredInput {
  create?: LiteratureSourceCreateInput;
  update?: LiteratureSourceUpdateDataInput;
  upsert?: LiteratureSourceUpsertNestedInput;
  connect?: LiteratureSourceWhereUniqueInput;
}

export interface LiteratureSourceUpdateDataInput {
  sourceCodes?: LiteratureSourceUpdatesourceCodesInput;
}

export interface LiteratureSourceUpdatesourceCodesInput {
  set?: String[] | String;
}

export interface LiteratureSourceUpsertNestedInput {
  update: LiteratureSourceUpdateDataInput;
  create: LiteratureSourceCreateInput;
}

export interface CompoundUpdateManyMutationInput {
  uniqueID?: String;
  commonName?: String;
  smiles?: String;
  chemicalFormula?: String;
  structurePicAdd?: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
}

export interface LiteratureSourceUpdateInput {
  sourceCodes?: LiteratureSourceUpdatesourceCodesInput;
}

export interface LiteratureSourceUpdateManyMutationInput {
  sourceCodes?: LiteratureSourceUpdatesourceCodesInput;
}

export interface MSDataUpdateInput {
  parentValue1?: Float;
  parentValue2?: Float;
  parentValue3?: Float;
  parentValue4?: Float;
  parentValue5?: Float;
  parentValue6?: Float;
  fragmentsValues1?: MSDataUpdatefragmentsValues1Input;
  fragmentsValues2?: MSDataUpdatefragmentsValues2Input;
  dataSource1?: MSDataUpdatedataSource1Input;
  referenceCodes1?: MSDataUpdatereferenceCodes1Input;
  dataSource2?: MSDataUpdatedataSource2Input;
  referenceCodes2?: MSDataUpdatereferenceCodes2Input;
  spectrumPicAddArray1?: MSDataUpdatespectrumPicAddArray1Input;
  spectrumPicAddArray2?: MSDataUpdatespectrumPicAddArray2Input;
}

export interface MSDataUpdateManyMutationInput {
  parentValue1?: Float;
  parentValue2?: Float;
  parentValue3?: Float;
  parentValue4?: Float;
  parentValue5?: Float;
  parentValue6?: Float;
  fragmentsValues1?: MSDataUpdatefragmentsValues1Input;
  fragmentsValues2?: MSDataUpdatefragmentsValues2Input;
  dataSource1?: MSDataUpdatedataSource1Input;
  referenceCodes1?: MSDataUpdatereferenceCodes1Input;
  dataSource2?: MSDataUpdatedataSource2Input;
  referenceCodes2?: MSDataUpdatereferenceCodes2Input;
  spectrumPicAddArray1?: MSDataUpdatespectrumPicAddArray1Input;
  spectrumPicAddArray2?: MSDataUpdatespectrumPicAddArray2Input;
}

export interface UserCreateInput {
  name?: String;
  email: String;
  password: String;
  role?: RoleType;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  role?: RoleType;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
  role?: RoleType;
}

export interface CompoundSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompoundWhereInput;
  AND?: CompoundSubscriptionWhereInput[] | CompoundSubscriptionWhereInput;
  OR?: CompoundSubscriptionWhereInput[] | CompoundSubscriptionWhereInput;
  NOT?: CompoundSubscriptionWhereInput[] | CompoundSubscriptionWhereInput;
}

export interface LiteratureSourceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LiteratureSourceWhereInput;
  AND?:
    | LiteratureSourceSubscriptionWhereInput[]
    | LiteratureSourceSubscriptionWhereInput;
  OR?:
    | LiteratureSourceSubscriptionWhereInput[]
    | LiteratureSourceSubscriptionWhereInput;
  NOT?:
    | LiteratureSourceSubscriptionWhereInput[]
    | LiteratureSourceSubscriptionWhereInput;
}

export interface MSDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MSDataWhereInput;
  AND?: MSDataSubscriptionWhereInput[] | MSDataSubscriptionWhereInput;
  OR?: MSDataSubscriptionWhereInput[] | MSDataSubscriptionWhereInput;
  NOT?: MSDataSubscriptionWhereInput[] | MSDataSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Compound {
  id: ID_Output;
  uniqueID: String;
  commonName: String;
  smiles: String;
  chemicalFormula: String;
  structurePicAdd?: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
}

export interface CompoundPromise extends Promise<Compound>, Fragmentable {
  id: () => Promise<ID_Output>;
  uniqueID: () => Promise<String>;
  commonName: () => Promise<String>;
  smiles: () => Promise<String>;
  chemicalFormula: () => Promise<String>;
  structurePicAdd: () => Promise<String>;
  casCode: () => Promise<String>;
  pubChemCID: () => Promise<String>;
  chemSpiderID: () => Promise<String>;
  msData: <T = MSDataPromise>() => T;
  literatureSource: <T = LiteratureSourcePromise>() => T;
}

export interface CompoundSubscription
  extends Promise<AsyncIterator<Compound>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uniqueID: () => Promise<AsyncIterator<String>>;
  commonName: () => Promise<AsyncIterator<String>>;
  smiles: () => Promise<AsyncIterator<String>>;
  chemicalFormula: () => Promise<AsyncIterator<String>>;
  structurePicAdd: () => Promise<AsyncIterator<String>>;
  casCode: () => Promise<AsyncIterator<String>>;
  pubChemCID: () => Promise<AsyncIterator<String>>;
  chemSpiderID: () => Promise<AsyncIterator<String>>;
  msData: <T = MSDataSubscription>() => T;
  literatureSource: <T = LiteratureSourceSubscription>() => T;
}

export interface MSData {
  id: ID_Output;
  parentValue1?: Float;
  parentValue2?: Float;
  parentValue3?: Float;
  parentValue4?: Float;
  parentValue5?: Float;
  parentValue6?: Float;
  fragmentsValues1: Float[];
  fragmentsValues2: Float[];
  dataSource1: String[];
  referenceCodes1: String[];
  dataSource2: String[];
  referenceCodes2: String[];
  spectrumPicAddArray1: String[];
  spectrumPicAddArray2: String[];
}

export interface MSDataPromise extends Promise<MSData>, Fragmentable {
  id: () => Promise<ID_Output>;
  parentValue1: () => Promise<Float>;
  parentValue2: () => Promise<Float>;
  parentValue3: () => Promise<Float>;
  parentValue4: () => Promise<Float>;
  parentValue5: () => Promise<Float>;
  parentValue6: () => Promise<Float>;
  fragmentsValues1: () => Promise<Float[]>;
  fragmentsValues2: () => Promise<Float[]>;
  dataSource1: () => Promise<String[]>;
  referenceCodes1: () => Promise<String[]>;
  dataSource2: () => Promise<String[]>;
  referenceCodes2: () => Promise<String[]>;
  spectrumPicAddArray1: () => Promise<String[]>;
  spectrumPicAddArray2: () => Promise<String[]>;
}

export interface MSDataSubscription
  extends Promise<AsyncIterator<MSData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentValue1: () => Promise<AsyncIterator<Float>>;
  parentValue2: () => Promise<AsyncIterator<Float>>;
  parentValue3: () => Promise<AsyncIterator<Float>>;
  parentValue4: () => Promise<AsyncIterator<Float>>;
  parentValue5: () => Promise<AsyncIterator<Float>>;
  parentValue6: () => Promise<AsyncIterator<Float>>;
  fragmentsValues1: () => Promise<AsyncIterator<Float[]>>;
  fragmentsValues2: () => Promise<AsyncIterator<Float[]>>;
  dataSource1: () => Promise<AsyncIterator<String[]>>;
  referenceCodes1: () => Promise<AsyncIterator<String[]>>;
  dataSource2: () => Promise<AsyncIterator<String[]>>;
  referenceCodes2: () => Promise<AsyncIterator<String[]>>;
  spectrumPicAddArray1: () => Promise<AsyncIterator<String[]>>;
  spectrumPicAddArray2: () => Promise<AsyncIterator<String[]>>;
}

export interface LiteratureSource {
  id: ID_Output;
  sourceCodes: String[];
}

export interface LiteratureSourcePromise
  extends Promise<LiteratureSource>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sourceCodes: () => Promise<String[]>;
}

export interface LiteratureSourceSubscription
  extends Promise<AsyncIterator<LiteratureSource>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sourceCodes: () => Promise<AsyncIterator<String[]>>;
}

export interface CompoundConnection {
  pageInfo: PageInfo;
  edges: CompoundEdge[];
}

export interface CompoundConnectionPromise
  extends Promise<CompoundConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompoundEdge>>() => T;
  aggregate: <T = AggregateCompoundPromise>() => T;
}

export interface CompoundConnectionSubscription
  extends Promise<AsyncIterator<CompoundConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompoundEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompoundSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CompoundEdge {
  node: Compound;
  cursor: String;
}

export interface CompoundEdgePromise
  extends Promise<CompoundEdge>,
    Fragmentable {
  node: <T = CompoundPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompoundEdgeSubscription
  extends Promise<AsyncIterator<CompoundEdge>>,
    Fragmentable {
  node: <T = CompoundSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompound {
  count: Int;
}

export interface AggregateCompoundPromise
  extends Promise<AggregateCompound>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompoundSubscription
  extends Promise<AsyncIterator<AggregateCompound>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LiteratureSourceConnection {
  pageInfo: PageInfo;
  edges: LiteratureSourceEdge[];
}

export interface LiteratureSourceConnectionPromise
  extends Promise<LiteratureSourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LiteratureSourceEdge>>() => T;
  aggregate: <T = AggregateLiteratureSourcePromise>() => T;
}

export interface LiteratureSourceConnectionSubscription
  extends Promise<AsyncIterator<LiteratureSourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LiteratureSourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLiteratureSourceSubscription>() => T;
}

export interface LiteratureSourceEdge {
  node: LiteratureSource;
  cursor: String;
}

export interface LiteratureSourceEdgePromise
  extends Promise<LiteratureSourceEdge>,
    Fragmentable {
  node: <T = LiteratureSourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LiteratureSourceEdgeSubscription
  extends Promise<AsyncIterator<LiteratureSourceEdge>>,
    Fragmentable {
  node: <T = LiteratureSourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLiteratureSource {
  count: Int;
}

export interface AggregateLiteratureSourcePromise
  extends Promise<AggregateLiteratureSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLiteratureSourceSubscription
  extends Promise<AsyncIterator<AggregateLiteratureSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MSDataConnection {
  pageInfo: PageInfo;
  edges: MSDataEdge[];
}

export interface MSDataConnectionPromise
  extends Promise<MSDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MSDataEdge>>() => T;
  aggregate: <T = AggregateMSDataPromise>() => T;
}

export interface MSDataConnectionSubscription
  extends Promise<AsyncIterator<MSDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MSDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMSDataSubscription>() => T;
}

export interface MSDataEdge {
  node: MSData;
  cursor: String;
}

export interface MSDataEdgePromise extends Promise<MSDataEdge>, Fragmentable {
  node: <T = MSDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MSDataEdgeSubscription
  extends Promise<AsyncIterator<MSDataEdge>>,
    Fragmentable {
  node: <T = MSDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMSData {
  count: Int;
}

export interface AggregateMSDataPromise
  extends Promise<AggregateMSData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMSDataSubscription
  extends Promise<AsyncIterator<AggregateMSData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name?: String;
  email: String;
  password: String;
  role: RoleType;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<RoleType>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<RoleType>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CompoundSubscriptionPayload {
  mutation: MutationType;
  node: Compound;
  updatedFields: String[];
  previousValues: CompoundPreviousValues;
}

export interface CompoundSubscriptionPayloadPromise
  extends Promise<CompoundSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompoundPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompoundPreviousValuesPromise>() => T;
}

export interface CompoundSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompoundSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompoundSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompoundPreviousValuesSubscription>() => T;
}

export interface CompoundPreviousValues {
  id: ID_Output;
  uniqueID: String;
  commonName: String;
  smiles: String;
  chemicalFormula: String;
  structurePicAdd?: String;
  casCode?: String;
  pubChemCID?: String;
  chemSpiderID?: String;
}

export interface CompoundPreviousValuesPromise
  extends Promise<CompoundPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uniqueID: () => Promise<String>;
  commonName: () => Promise<String>;
  smiles: () => Promise<String>;
  chemicalFormula: () => Promise<String>;
  structurePicAdd: () => Promise<String>;
  casCode: () => Promise<String>;
  pubChemCID: () => Promise<String>;
  chemSpiderID: () => Promise<String>;
}

export interface CompoundPreviousValuesSubscription
  extends Promise<AsyncIterator<CompoundPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uniqueID: () => Promise<AsyncIterator<String>>;
  commonName: () => Promise<AsyncIterator<String>>;
  smiles: () => Promise<AsyncIterator<String>>;
  chemicalFormula: () => Promise<AsyncIterator<String>>;
  structurePicAdd: () => Promise<AsyncIterator<String>>;
  casCode: () => Promise<AsyncIterator<String>>;
  pubChemCID: () => Promise<AsyncIterator<String>>;
  chemSpiderID: () => Promise<AsyncIterator<String>>;
}

export interface LiteratureSourceSubscriptionPayload {
  mutation: MutationType;
  node: LiteratureSource;
  updatedFields: String[];
  previousValues: LiteratureSourcePreviousValues;
}

export interface LiteratureSourceSubscriptionPayloadPromise
  extends Promise<LiteratureSourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LiteratureSourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LiteratureSourcePreviousValuesPromise>() => T;
}

export interface LiteratureSourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LiteratureSourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LiteratureSourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LiteratureSourcePreviousValuesSubscription>() => T;
}

export interface LiteratureSourcePreviousValues {
  id: ID_Output;
  sourceCodes: String[];
}

export interface LiteratureSourcePreviousValuesPromise
  extends Promise<LiteratureSourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sourceCodes: () => Promise<String[]>;
}

export interface LiteratureSourcePreviousValuesSubscription
  extends Promise<AsyncIterator<LiteratureSourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sourceCodes: () => Promise<AsyncIterator<String[]>>;
}

export interface MSDataSubscriptionPayload {
  mutation: MutationType;
  node: MSData;
  updatedFields: String[];
  previousValues: MSDataPreviousValues;
}

export interface MSDataSubscriptionPayloadPromise
  extends Promise<MSDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MSDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MSDataPreviousValuesPromise>() => T;
}

export interface MSDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MSDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MSDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MSDataPreviousValuesSubscription>() => T;
}

export interface MSDataPreviousValues {
  id: ID_Output;
  parentValue1?: Float;
  parentValue2?: Float;
  parentValue3?: Float;
  parentValue4?: Float;
  parentValue5?: Float;
  parentValue6?: Float;
  fragmentsValues1: Float[];
  fragmentsValues2: Float[];
  dataSource1: String[];
  referenceCodes1: String[];
  dataSource2: String[];
  referenceCodes2: String[];
  spectrumPicAddArray1: String[];
  spectrumPicAddArray2: String[];
}

export interface MSDataPreviousValuesPromise
  extends Promise<MSDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentValue1: () => Promise<Float>;
  parentValue2: () => Promise<Float>;
  parentValue3: () => Promise<Float>;
  parentValue4: () => Promise<Float>;
  parentValue5: () => Promise<Float>;
  parentValue6: () => Promise<Float>;
  fragmentsValues1: () => Promise<Float[]>;
  fragmentsValues2: () => Promise<Float[]>;
  dataSource1: () => Promise<String[]>;
  referenceCodes1: () => Promise<String[]>;
  dataSource2: () => Promise<String[]>;
  referenceCodes2: () => Promise<String[]>;
  spectrumPicAddArray1: () => Promise<String[]>;
  spectrumPicAddArray2: () => Promise<String[]>;
}

export interface MSDataPreviousValuesSubscription
  extends Promise<AsyncIterator<MSDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentValue1: () => Promise<AsyncIterator<Float>>;
  parentValue2: () => Promise<AsyncIterator<Float>>;
  parentValue3: () => Promise<AsyncIterator<Float>>;
  parentValue4: () => Promise<AsyncIterator<Float>>;
  parentValue5: () => Promise<AsyncIterator<Float>>;
  parentValue6: () => Promise<AsyncIterator<Float>>;
  fragmentsValues1: () => Promise<AsyncIterator<Float[]>>;
  fragmentsValues2: () => Promise<AsyncIterator<Float[]>>;
  dataSource1: () => Promise<AsyncIterator<String[]>>;
  referenceCodes1: () => Promise<AsyncIterator<String[]>>;
  dataSource2: () => Promise<AsyncIterator<String[]>>;
  referenceCodes2: () => Promise<AsyncIterator<String[]>>;
  spectrumPicAddArray1: () => Promise<AsyncIterator<String[]>>;
  spectrumPicAddArray2: () => Promise<AsyncIterator<String[]>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name?: String;
  email: String;
  password: String;
  role: RoleType;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<RoleType>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<RoleType>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Compound",
    embedded: false
  },
  {
    name: "LiteratureSource",
    embedded: false
  },
  {
    name: "MSData",
    embedded: false
  },
  {
    name: "RoleType",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
